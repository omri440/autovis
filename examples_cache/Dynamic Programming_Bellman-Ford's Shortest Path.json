{
  "name": "Bellman-Ford's Shortest Path",
  "path": "Dynamic Programming/Bellman-Ford's Shortest Path/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst tracer = new GraphTracer().weighted();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.log(logger);\nconst G = Randomize.Graph({ N: 5, ratio: .5, value: () => Randomize.Integer({ min: -2, max: 5 }), weighted: true });\ntracer.set(G);\nTracer.delay();\n// }\n\nfunction BELLMAN_FORD(src, dest) {\n  const weights = new Array(G.length);\n  let i;\n  let j;\n\n  for (i = 0; i < G.length; i++) {\n    weights[i] = MAX_VALUE;\n    // visualize {\n    tracer.updateNode(i, weights[i]);\n    // }\n  }\n  weights[src] = 0;\n  // visualize {\n  tracer.updateNode(src, 0);\n  // }\n\n  // logger {\n  logger.println(`Initializing weights to: [${weights}]`);\n  logger.println('');\n  // }\n\n  // begin BF algorithm execution\n  let k = G.length;\n  while (k--) {\n    // logger {\n    logger.println(`Iteration: ${G.length - k}`);\n    logger.println('------------------------------------------------------------------');\n    // }\n\n    for (i = 0; i < G.length; i++) {\n      for (j = 0; j < G.length; j++) {\n        if (G[i][j]) { // proceed to relax Edges only if a particular weight !== 0 (0 represents no edge)\n          if (weights[j] > (weights[i] + G[i][j])) {\n            weights[j] = weights[i] + G[i][j];\n            // logger {\n            logger.println(`weights[${j}] = weights[${i}] + ${G[i][j]}`);\n            // }\n          }\n          // visualize {\n          tracer.visit(j, i, weights[j]);\n          Tracer.delay();\n          tracer.leave(j, i);\n          Tracer.delay();\n          // }\n        }\n      }\n    }\n\n    // logger {\n    logger.println(`updated weights: [${weights.join(', ')}]`);\n    logger.println('');\n    // }\n  }\n\n  // check for cycle\n  logger.println('checking for cycle');\n  for (i = 0; i < G.length; i++) {\n    for (j = 0; j < G.length; j++) {\n      if (G[i][j]) {\n        if (weights[j] > (weights[i] + G[i][j])) {\n          // logger {\n          logger.println(`A cycle was detected: weights[${j}] > weights[${i}] + ${G[i][j]}`);\n          // }\n          return (MAX_VALUE);\n        }\n      }\n    }\n  }\n\n  // logger {\n  logger.println(`No cycles detected. Final weights for the source ${src} are: [${weights}]`);\n  // }\n\n  return weights[dest];\n}\n\nconst src = Randomize.Integer({ min: 0, max: G.length - 1 });\nlet dest;\nlet MAX_VALUE = 0x7fffffff;\nlet minWeight;\n\n/*\n src = start node\n dest = start node (but will eventually at as the end node)\n */\n\ndo {\n  dest = Randomize.Integer({ min: 0, max: G.length - 1 });\n}\nwhile (src === dest);\n\n// logger {\nlogger.println(`finding the shortest path from ${src} to ${dest}`);\n// }\n\nminWeight = BELLMAN_FORD(src, dest);\n\n// logger {\nif (minWeight === MAX_VALUE) {\n  logger.println(`there is no path from ${src} to ${dest}`);\n} else {\n  logger.println(`the shortest path from ${src} to ${dest} is ${minWeight}`);\n}\n// }\n",
  "category": "dynamic_programming",
  "patterns": [
    "uses_randomize",
    "has_logging"
  ]
}