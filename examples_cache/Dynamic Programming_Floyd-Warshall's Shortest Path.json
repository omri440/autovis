{
  "name": "Floyd-Warshall's Shortest Path",
  "path": "Dynamic Programming/Floyd-Warshall's Shortest Path/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst tracer = new GraphTracer().weighted();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.log(logger);\nconst G = Randomize.Graph({ N: 5, ratio: 1, weighted: true });\ntracer.set(G);\nTracer.delay();\n// }\n\nfunction FloydWarshall() {\n  // Finds the shortest path between all nodes\n  const S = new Array(G.length);\n  for (let i = 0; i < G.length; i++) S[i] = new Array(G.length);\n  for (let i = 0; i < G.length; i++) {\n    for (let j = 0; j < G.length; j++) {\n      // Distance to self is always 0\n      if (i === j) S[i][i] = 0;\n      // Distance between connected nodes is their weight\n      else if (G[i][j] > 0) {\n        S[i][j] = G[i][j];\n      }// Else we don't know the distance and we set it to infinity\n      else S[i][j] = MAX_VALUE;\n    }\n  }\n  // If there is a shorter path using k, use it instead\n  for (let k = 0; k < G.length; k++) {\n    for (let i = 0; i < G.length; i++) {\n      if (k === i) continue;\n      // visualize {\n      tracer.visit(k, i);\n      Tracer.delay();\n      // }\n      for (let j = 0; j < G.length; j++) {\n        if (i === j || j === k) continue;\n        // visualize {\n        tracer.visit(j, k);\n        Tracer.delay();\n        // }\n        if (S[i][j] > S[i][k] + S[k][j]) {\n          // visualize {\n          tracer.visit(j, i, S[i][j]);\n          Tracer.delay();\n          // }\n          S[i][j] = S[i][k] + S[k][j];\n          // visualize {\n          tracer.leave(j, i, S[i][j]);\n          // }\n        }\n        // visualize {\n        tracer.leave(j, k);\n        // }\n      }\n      // visualize {\n      tracer.leave(k, i);\n      Tracer.delay();\n      // }\n    }\n  }\n  // logger {\n  for (let i = 0; i < G.length; i++) {\n    for (let j = 0; j < G.length; j++) {\n      if (S[i][j] === MAX_VALUE) logger.println(`there is no path from ${i} to ${j}`);\n      else logger.println(`the shortest path from ${i} to ${j} is ${S[i][j]}`);\n    }\n  }\n  // }\n}\n\nlet MAX_VALUE = Infinity;\n// logger {\nlogger.println('finding the shortest paths from and to all nodes');\n// }\nFloydWarshall();\n",
  "category": "dynamic_programming",
  "patterns": [
    "uses_randomize",
    "has_logging"
  ]
}