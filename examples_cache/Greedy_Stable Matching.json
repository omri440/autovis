{
  "name": "Stable Matching",
  "path": "Greedy/Stable Matching/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst ARank = {\n  Flavio: ['Valentine', 'July', 'Summer', 'Violet'],\n  Stephen: ['Summer', 'July', 'Valentine', 'Violet'],\n  Albert: ['July', 'Violet', 'Valentine', 'Summer'],\n  Jack: ['July', 'Violet', 'Valentine', 'Summer'],\n};\n\nconst BRank = {\n  July: ['Jack', 'Stephen', 'Albert', 'Flavio'],\n  Valentine: ['Flavio', 'Jack', 'Stephen', 'Albert'],\n  Violet: ['Jack', 'Stephen', 'Flavio', 'Albert'],\n  Summer: ['Stephen', 'Flavio', 'Albert', 'Jack'],\n};\n\n// define tracer variables {\nconst tracerA = new Array1DTracer('A');\nconst tracerB = new Array1DTracer('B');\n\nconst _aKeys = Object.keys(ARank);\nconst _bKeys = Object.keys(BRank);\ntracerA.set(_aKeys);\ntracerB.set(_bKeys);\n\nconst logTracer = new LogTracer('Console');\nLayout.setRoot(new VerticalLayout([tracerA, tracerB, logTracer]));\nTracer.delay();\n// }\n\nfunction init(rank) {\n  const o = {};\n  for (const k in rank) {\n    o[k] = {\n      key: k,\n      stable: false,\n      rankKeys: rank[k],\n    };\n  }\n  return o;\n}\n\nfunction extractUnstable(Q) {\n  for (const k in Q) {\n    if (Q[k].stable === false) {\n      return Q[k];\n    }\n  }\n}\n\nconst A = init(ARank);\nconst B = init(BRank);\nlet a;\n\nwhile ((a = extractUnstable(A))) {\n  // logger {\n  logTracer.println(`Selecting ${a.key}`);\n  Tracer.delay();\n  // }\n\n  const bKey = a.rankKeys.shift();\n  const b = B[bKey];\n\n  // logger {\n  logTracer.println(`--> Choicing ${b.key}`);\n  Tracer.delay();\n  // }\n\n  if (b.stable === false) {\n    // logger {\n    logTracer.println(`--> ${b.key} is not stable, stabilizing with ${a.key}`);\n    Tracer.delay();\n    // }\n\n    a.stable = b;\n    b.stable = a;\n\n    // visualize {\n    tracerA.select(_aKeys.indexOf(a.key));\n    Tracer.delay();\n    tracerB.select(_bKeys.indexOf(b.key));\n    Tracer.delay();\n    // }\n  } else {\n    const rankAinB = b.rankKeys.indexOf(a.key);\n    const rankPrevAinB = b.rankKeys.indexOf(b.stable.key);\n    if (rankAinB < rankPrevAinB) {\n      // logger {\n      logTracer.println(`--> ${bKey} is more stable with ${a.key} rather than ${b.stable.key} - stabilizing again`);\n      Tracer.delay();\n      // }\n\n      A[b.stable.key].stable = false;\n      // visualize {\n      tracerA.deselect(_aKeys.indexOf(b.stable.key));\n      Tracer.delay();\n      // }\n\n      a.stable = b;\n      b.stable = a;\n\n      // visualize {\n      tracerA.select(_aKeys.indexOf(a.key));\n      Tracer.delay();\n      tracerB.select(_bKeys.indexOf(b.key));\n      Tracer.delay();\n      // }\n    }\n  }\n}\n",
  "category": "greedy",
  "patterns": [
    "select_deselect"
  ]
}