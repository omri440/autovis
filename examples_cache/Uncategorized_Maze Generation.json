{
  "name": "Maze Generation",
  "path": "Uncategorized/Maze Generation/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst n = 6; // rows (change these!)\nconst m = 6; // columns (change these!)\n\nconst hEnd = m * 4 - (m - 1);\nconst vEnd = n * 3 - (n - 1);\n\nconst G = [];\n\nfor (let i = 0; i < vEnd; i++) { // by row\n  G[i] = new Array(hEnd);\n  for (let j = 0; j < hEnd; j++) { // by column\n    G[i][j] = ' ';\n\n    if (i === 0 && j === 0) { // top-left corner\n      G[i][j] = '\u250c';\n    } else if (i === 0 && j === hEnd - 1) { // top-right corner\n      G[i][j] = '\u2510';\n    } else if (i === vEnd - 1 && j === 0) { // bottom-left corner\n      G[i][j] = '\u2514';\n    } else if (i === vEnd - 1 && j === hEnd - 1) { // bottom-right corner\n      G[i][j] = '\u2518';\n    } else if ((j % 3 === 0) && (i % vEnd !== 0 && i !== vEnd - 1 && i % 2 === 1)) {\n      G[i][j] = '\u2502';\n    } else if (i % 2 === 0) {\n      G[i][j] = '\u2500';\n    }\n\n    if (m > 1) { // More than one column\n      if (j % 3 === 0 && j !== 0 && j !== hEnd - 1 && i === 0) {\n        G[i][j] = '\u252c';\n      }\n      if (j % 3 === 0 && j !== 0 && j !== hEnd - 1 && i === vEnd - 1) {\n        G[i][j] = '\u2534';\n      }\n    }\n\n    if (n > 1) { // More than one row\n      if (i % 2 === 0 && i !== 0 && i !== vEnd - 1 && j === 0) {\n        G[i][j] = '\u251c';\n      }\n      if (i % 2 === 0 && i !== 0 && i !== vEnd - 1 && j === hEnd - 1) {\n        G[i][j] = '\u2524';\n      }\n    }\n\n    if (n > 1 && m > 1) { // More than one row and column\n      if (i % 2 === 0 && j % 3 === 0 && i !== 0 && j !== 0 && i !== vEnd - 1 && j !== hEnd - 1) {\n        G[i][j] = '\u253c';\n      }\n    }\n  }\n}\n\n// define tracer variables {\nconst tracer = new Array2DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.set(G);\nTracer.delay();\n// }\n\nfunction buildMaze() {\n  const mySet = new disjointSet();\n  const width = m;\n  const height = n;\n  let setSize = 0;\n  const graph = [];\n  const visitedMap = {};\n  const walls = {};\n  const rightWalls = [];\n  const downWalls = [];\n  let location = 0;\n\n  mySet.addElements(width * height);\n\n  // logger {\n  logger.println('initializing grid (all walls are up)');\n  // }\n  // init 'graph'\n  // each room has two walls, a down and right wall.\n  for (let i = 0; i < width; i++) {\n    graph[i] = new Array(height);\n    for (let j = 0; j < height; j++) {\n      graph[i][j] = location;\n\n      walls[location] = { down: true, right: true };\n      visitedMap[location] = false;\n\n      // If you can label the rooms with just 2 digits\n      if (width * height < 100) {\n        const locationString = location.toString();\n\n        G[j * 2 + 1][i * 3 + 1] = locationString[0];\n        G[j * 2 + 1][i * 3 + 2] = locationString[1];\n\n        // visualize {\n        tracer.set(G);\n        // }\n      }\n\n      rightWalls.push({ x: i, y: j });\n      downWalls.push({ x: i, y: j });\n      location++;\n    }\n  }\n\n  // logger {\n  logger.println('shuffled the walls for random selection');\n  // }\n  // Randomly shuffle the walls\n  shuffle(rightWalls);\n  shuffle(downWalls);\n\n  // Picking random walls to remove\n  while (setSize !== mySet.elements - 1) {\n    const randomWall = Math.floor((Math.random() * 2) + 1);\n    if (randomWall === 1 && downWalls.length > 0) {\n      // Down wall\n      const currentRoom = downWalls.pop();\n      const iX = currentRoom.x;\n      const iY = currentRoom.y;\n      const iYdown = iY + 1;\n      if (iYdown < height) {\n        const u = graph[iX][iY];\n        const v = graph[iX][iYdown];\n        // visualize {\n        tracer.patch(iY * 2 + 1, iX * 3 + 1);\n        tracer.patch(iY * 2 + 1, iX * 3 + 2);\n        tracer.patch(iYdown * 2 + 1, iX * 3 + 1);\n        tracer.patch(iYdown * 2 + 1, iX * 3 + 2);\n        // }\n        if (mySet.find(u) !== mySet.find(v)) {\n          // logger {\n          logger.println(`Rooms: ${u} & ${v} now belong to the same set, delete wall between them`);\n\n          Tracer.delay();\n          // }\n          mySet.setUnion(u, v);\n          setSize++;\n          // delete wall\n          walls[u].down = false;\n        } else {\n          // logger {\n          logger.println(`Rooms: ${u} & ${v} would create a cycle! This is not good!`);\n          Tracer.delay();\n          // }\n        }\n        // visualize {\n        tracer.depatch(iY * 2 + 1, iX * 3 + 1);\n        tracer.depatch(iY * 2 + 1, iX * 3 + 2);\n        tracer.depatch(iYdown * 2 + 1, iX * 3 + 1);\n        tracer.depatch(iYdown * 2 + 1, iX * 3 + 2);\n        // }\n      }\n    } else if (randomWall === 2 && rightWalls.length > 0) {\n      // Right Wall\n      const currentRoom = rightWalls.pop();\n      const iX = currentRoom.x;\n      const iY = currentRoom.y;\n      const iXright = iX + 1;\n      if (iXright < width) {\n        const u = graph[iX][iY];\n        const v = graph[iXright][iY];\n        // visualize {\n        tracer.patch(iY * 2 + 1, iX * 3 + 1);\n        tracer.patch(iY * 2 + 1, iX * 3 + 2);\n        tracer.patch(iY * 2 + 1, iXright * 3 + 1);\n        tracer.patch(iY * 2 + 1, iXright * 3 + 2);\n        // }\n        if (mySet.find(u) !== mySet.find(v)) {\n          // logger {\n          logger.println(`Rooms: ${u} & ${v} now belong to the same set, delete wall between them`);\n\n          Tracer.delay();\n          // }\n          mySet.setUnion(u, v);\n          setSize++;\n          // delete wall\n          walls[u].right = false;\n        } else {\n          // logger {\n          logger.println(`Rooms: ${u} & ${v} would create a cycle! This is not good!`);\n          Tracer.delay();\n          // }\n        }\n        // visualize {\n        tracer.depatch(iY * 2 + 1, iX * 3 + 1);\n        tracer.depatch(iY * 2 + 1, iX * 3 + 2);\n        tracer.depatch(iY * 2 + 1, iXright * 3 + 1);\n        tracer.depatch(iY * 2 + 1, iXright * 3 + 2);\n        // }\n      }\n    }\n  }\n\n  // logger {\n  logger.println('deleting the walls');\n  // }\n  // update deleted walls\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < height; j++) {\n      const currentWall = walls[graph[i][j]];\n\n      if (currentWall.down === false) {\n        G[j * 2 + 2][i * 3 + 1] = ' ';\n        G[j * 2 + 2][i * 3 + 2] = ' ';\n        // visualize {\n        tracer.select(j * 2 + 2, i * 3 + 1);\n        Tracer.delay();\n        tracer.select(j * 2 + 2, i * 3 + 2);\n        Tracer.delay();\n        // }\n      }\n\n      if (currentWall.right === false) {\n        G[j * 2 + 1][i * 3 + 3] = ' ';\n        // visualize {\n        tracer.select(j * 2 + 1, i * 3 + 3);\n        Tracer.delay();\n        // }\n      }\n      // visualize {\n      tracer.set(G);\n      // }\n    }\n  }\n  // logger {\n  logger.println('cleaning up the grid!');\n  // }\n  cleanUpGrid(width, height);\n\n  // Clear out walls for the start and end locations.\n  const randomStart = Math.floor(Math.random() * width);\n  const randomEnd = Math.floor(Math.random() * width);\n\n  // logger {\n  logger.println('setting the Start (S) & End (E) locations');\n  // }\n\n  // Start Location\n  G[0][randomStart * 3 + 1] = ' ';\n  G[0][randomStart * 3 + 2] = ' ';\n  G[1][randomStart * 3 + 1] = 'S';\n\n  // End Location\n  G[vEnd - 1][randomEnd * 3 + 1] = ' ';\n  G[vEnd - 1][randomEnd * 3 + 2] = ' ';\n  G[vEnd - 2][randomEnd * 3 + 1] = 'E';\n\n  cleanUpStartLocation(randomStart);\n  cleanUpEndLocation(randomEnd);\n\n  // logger {\n  logger.println('maze is completed!');\n  // }\n\n  // set the data\n  // visualize {\n  tracer.set(G);\n  // }\n}\n\nfunction cleanUpStartLocation(start) {\n  if (G[0][start * 3] === '\u252c' && G[1][start * 3] === '\u2502') {\n    G[0][start * 3] = '\u2510';\n  }\n  if (G[0][start * 3 + 3] === '\u252c' && G[1][start * 3 + 3] === '\u2502') {\n    G[0][start * 3 + 3] = '\u250c';\n  }\n  if (G[0][start * 3] === '\u250c') {\n    G[0][start * 3] = '\u2502';\n  }\n  if (G[0][start * 3 + 3] === '\u2510') {\n    G[0][start * 3 + 3] = '\u2502';\n  }\n}\n\nfunction cleanUpEndLocation(end) {\n  if (G[vEnd - 1][end * 3] === '\u2534' && G[vEnd - 2][end * 3] === '\u2502') {\n    G[vEnd - 1][end * 3] = '\u2518';\n  }\n  if (G[vEnd - 1][end * 3 + 3] === '\u2534' && G[vEnd - 2][end * 3 + 3] === '\u2502') {\n    G[vEnd - 1][end * 3 + 3] = '\u2514';\n  }\n  if (G[vEnd - 1][end * 3] === '\u2514') {\n    G[vEnd - 1][end * 3] = '\u2502';\n  }\n  if (G[vEnd - 1][end * 3 + 3] === '\u2518') {\n    G[vEnd - 1][end * 3 + 3] = '\u2502';\n  }\n}\n\nfunction cleanUpGrid(width, height) {\n  // Remove room numbers\n  for (let i = 0; i < width; i++) {\n    for (let j = 0; j < height; j++) {\n      G[j * 2 + 1][i * 3 + 1] = ' ';\n      G[j * 2 + 1][i * 3 + 2] = ' ';\n    }\n  }\n\n  // clean up grid for looks\n  for (let i = 0; i < vEnd; i++) {\n    for (let j = 0; j < hEnd; j++) {\n      if (G[i][j] === '\u251c') {\n        if (G[i][j + 1] === ' ') {\n          G[i][j] = '\u2502';\n        }\n      }\n\n      if (G[i][j] === '\u2524') {\n        if (G[i][j - 1] === ' ') {\n          G[i][j] = '\u2502';\n        }\n      }\n\n      if (G[i][j] === '\u252c') {\n        if (G[i + 1][j] === ' ') {\n          G[i][j] = '\u2500';\n        }\n      }\n\n      if (G[i][j] === '\u2534') {\n        if (G[i - 1][j] === ' ') {\n          G[i][j] = '\u2500';\n        }\n      }\n\n      if (G[i][j] === '\u253c') {\n        if (G[i][j + 1] === ' ' && G[i - 1][j] === ' ' && G[i][j - 1] !== ' ' && G[i + 1][j] !== ' ') {\n          G[i][j] = '\u2510';\n        } else if (G[i][j - 1] === ' ' && G[i - 1][j] === ' ' && G[i + 1][j] !== ' ' && G[i][j + 1] !== ' ') {\n          G[i][j] = '\u250c';\n        } else if (G[i][j - 1] === ' ' && G[i + 1][j] === ' ' && G[i - 1][j] !== ' ' && G[i][j + 1] !== ' ') {\n          G[i][j] = '\u2514';\n        } else if (G[i][j + 1] === ' ' && G[i + 1][j] === ' ' && G[i - 1][j] !== ' ' && G[i][j - 1] !== ' ') {\n          G[i][j] = '\u2518';\n        } else if (G[i][j + 1] === ' ' && G[i][j - 1] === ' ' && (G[i + 1][j] === ' ' || G[i - 1][j] === ' ')) {\n          G[i][j] = '\u2502';\n        } else if (G[i + 1][j] === ' ' && G[i - 1][j] === ' ' && (G[i][j - 1] === ' ' || G[i][j + 1] === ' ')) {\n          G[i][j] = '\u2500';\n        } else if (G[i][j + 1] === ' ' && G[i][j - 1] === ' ') {\n          G[i][j] = '\u2502';\n        } else if (G[i + 1][j] === ' ' && G[i - 1][j] === ' ') {\n          G[i][j] = '\u2500';\n        } else if (G[i + 1][j] === ' ' && G[i - 1][j] !== ' ' && G[i][j - 1] !== ' ' && G[i][j + 1] !== ' ') {\n          G[i][j] = '\u2534';\n        } else if (G[i - 1][j] === ' ' && G[i + 1][j] !== ' ' && G[i][j + 1] !== ' ' && G[i][j - 1] !== ' ') {\n          G[i][j] = '\u252c';\n        } else if (G[i][j + 1] === ' ' && G[i - 1][j] !== ' ' && G[i + 1][j] !== ' ' && G[i][j - 1] !== ' ') {\n          G[i][j] = '\u2524';\n        } else if (G[i][j - 1] === ' ' && G[i - 1][j] !== ' ' && G[i + 1][j] !== ' ' && G[i][j + 1] !== ' ') {\n          G[i][j] = '\u251c';\n        }\n      }\n    }\n  }\n}\n\nclass disjointSet {\n  constructor() {\n    this.set = [];\n    this.elements = 0;\n  }\n\n  addElements(numberOfElements) {\n    for (let i = 0; i < numberOfElements; i++) {\n      this.elements++;\n      this.set.push(-1);\n    }\n  }\n\n  find(element) {\n    if (this.set[element] < 0) {\n      return element;\n    }\n    return this.set[element] = this.find(this.set[element]);\n  }\n\n  setUnion(_a, _b) {\n    const a = this.find(_a);\n    const b = this.find(_b);\n\n    if (a !== b) {\n      const newSize = (this.set[a] + this.set[b]);\n      if (this.compareSize(a, b)) {\n        this.set[b] = a;\n        this.set[a] = newSize;\n      } else {\n        this.set[a] = b;\n        this.set[b] = newSize;\n      }\n    }\n  }\n\n  compareSize(a, b) {\n    if (this.set[a] === this.set[b]) {\n      return true;\n    } else if (this.set[a] < this.set[b]) {\n      return true;\n    }\n    return false;\n  }\n}\n\n// http://bost.ocks.org/mike/shuffle/\nfunction shuffle(array) {\n  let m = array.length;\n  let t;\n  let i;\n  // While there remain elements to shuffle\u2026\n  while (m) {\n    // Pick a remaining element\u2026\n    i = Math.floor(Math.random() * m--);\n    // And swap it with the current element.\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n  return array;\n}\n\nbuildMaze();\n",
  "category": "other",
  "patterns": [
    "patch_depatch",
    "custom_data",
    "has_logging",
    "uses_2d_array"
  ]
}