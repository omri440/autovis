{
  "name": "PageRank",
  "path": "Brute Force/PageRank/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, Array2DTracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nfunction filledArray(length, value) {\n  return Array(...Array(length)).map(Number.prototype.valueOf, value);\n}\n\n// define tracer variables {\nconst G = Randomize.Graph({ N: 5, ratio: .4 });\nlet ranks;\nconst outgoingEdgeCounts = filledArray(G.length, 0);\nlet incomingNodes;\nconst graphTracer = new GraphTracer('Web Page inter-connections');\nconst rankTracer = new Array1DTracer('Web Page Ranks');\nconst oecTracer = new Array1DTracer('Outgoing Edge Counts');\nconst inTracer = new Array2DTracer('Incoming Nodes');\n\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([graphTracer, rankTracer, oecTracer, inTracer, logger]));\n\ngraphTracer.set(G);\noecTracer.set(outgoingEdgeCounts);\n\nfor (incomingNodes = []; incomingNodes.length < G.length; incomingNodes.push(filledArray(G.length, -1))) ;\ninTracer.set(incomingNodes);\nTracer.delay();\n// }\n\n/*\n  PageRank Algorithm Version 2\n  Equation:\n    PR (X) = ( (1 - D)/N ) + D (Summation i->X (PR (I) / Out (i)))\n  NOTE: Algorithm uses the recommended damping factor (D). Number of iterations is small because only a small Web of 5 Pages is simulated\n*/\n\nfunction arraySum(array) {\n  return array.reduce(\n    (sum, curr) =>\n      sum + (curr ? 1 : 0) // if curr is 0 (no edge) or undefined (loop not allowed), sum remains unchanged\n    , 0,\n  );\n}\n\nfunction showOutgoingEdges(i) {\n  G[i].forEach((edgeExists, j) => {\n    if (edgeExists) {\n      // visualize {\n      graphTracer.visit(j, i);\n      Tracer.delay();\n      graphTracer.leave(j, i);\n      Tracer.delay();\n      // }\n    }\n  });\n}\n\n// PRECOMPUTATIONS\n\n// logger {\nlogger.println('Calculate Outgoing Edge Count for each Node');\n// }\n(function calculateOEC() {\n  G.forEach((relations, i) => {\n    outgoingEdgeCounts[i] = arraySum(relations);\n    showOutgoingEdges(i);\n\n    // visualize {\n    oecTracer.patch(i, outgoingEdgeCounts[i]);\n    Tracer.delay();\n    oecTracer.depatch(i);\n    Tracer.delay();\n    // }\n  });\n}());\n\n// logger {\nlogger.println('determine incoming nodes for each node');\n// }\n(function determineIN() {\n  for (let i = 0; i < G.length; i++) {\n    for (let j = 0; j < G.length; j++) {\n      if (G[i][j]) {\n        // there's an edge FROM i TO j\n        // visualize {\n        graphTracer.visit(j, i);\n        Tracer.delay();\n        // }\n\n        const nextPos = incomingNodes[j].indexOf(-1);\n        incomingNodes[j][nextPos] = i;\n        // visualize {\n        inTracer.patch(j, nextPos, i);\n        Tracer.delay();\n        inTracer.depatch(j, nextPos);\n        Tracer.delay();\n\n        graphTracer.leave(j, i);\n        Tracer.delay();\n        // }\n      }\n    }\n  }\n\n  // logger.println ('All -1s will be removed from incoming node records, they are irrelevant');\n  incomingNodes.forEach((arr) => {\n    arr.splice(arr.indexOf(-1));\n  });\n}());\n\nfunction updateRank(nodeIndex) {\n  let inNodeSummation = 0;\n  let result;\n\n  // logger {\n  logger.println(`Updating rank of ${nodeIndex}`);\n  logger.println(`The incoming Nodes of ${nodeIndex} are being highlighted`);\n  // }\n\n  incomingNodes[nodeIndex].forEach((incoming, i) => {\n    // visualize {\n    inTracer.select(nodeIndex, i);\n    Tracer.delay();\n    logger.println(`Outgoing edge count of ${incoming} is ${outgoingEdgeCounts[incoming]}`);\n    oecTracer.select(incoming);\n    Tracer.delay();\n    // }\n\n    inNodeSummation += (ranks[incoming] / outgoingEdgeCounts[incoming]);\n\n    // visualize {\n    oecTracer.deselect(incoming);\n    Tracer.delay();\n    inTracer.deselect(nodeIndex, i);\n    Tracer.delay();\n    // }\n  });\n  // logger {\n  logger.println(`In-Node summation of ${nodeIndex} = ${inNodeSummation}`);\n  // }\n  \n  result = ((1 - damping) / G.length) + (damping * inNodeSummation); // notice the subtle difference between equations of Basic PR & PR version 2 (divide by N)\n  // logger {\n  logger.println(`Therefore, using Equation, new rank of ${nodeIndex} = ${result}`);\n  // }\n  return result;\n}\n\nlet damping = 0.85;\nlet iterations = 7;\nconst initialRank = 1.0;\n\n// logger {\nlogger.println(`Initialized all Page ranks to ${initialRank}`);\n// }\nranks = filledArray(G.length, initialRank);\n\n// visualize {\nrankTracer.set(ranks);\n// }\n// logger {\nlogger.println('Begin execution of PageRank Version #1');\nlogger.println('Equation used: PR (X) = (1 - D) + D (In-Node-Summation i->X (PR (I) / Out (i)))');\nlogger.println('D = Damping Factor, PR (X) = Page rank of Node X, i = the ith In-Node of X, Out (i) = outgoing Edge Count of i');\nlogger.println('');\n// }\n\nwhile (iterations--) {\n  for (let node = 0; node < ranks.length; node++) {\n    ranks[node] = updateRank(node);\n    // visualize {\n    rankTracer.patch(node, ranks[node]);\n    Tracer.delay();\n    rankTracer.patch(node);\n    Tracer.delay();\n    // }\n  }\n}\n\n// logger {\nlogger.println('Page Ranks have been converged to.');\nranks.forEach((rank, node) => {\n  logger.println(`Rank of Node #${node} = ${rank}`);\n});\nlogger.println('Done');\n// }\n",
  "category": "other",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "uses_randomize",
    "has_logging",
    "uses_2d_array"
  ]
}