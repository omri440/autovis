{
  "name": "Bridge Finding",
  "path": "Brute Force/Bridge Finding/naive.js",
  "code": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst G = [\n  [0, 1, 0, 0, 0, 0],\n  [1, 0, 0, 1, 1, 0],\n  [0, 0, 0, 1, 0, 0],\n  [0, 1, 1, 0, 1, 1],\n  [0, 1, 0, 1, 0, 0],\n  [0, 0, 0, 1, 0, 0],\n];\n\n// define tracer variables {\nconst tracer = new GraphTracer().directed(false);\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.set(G);\nTracer.delay();\n// }\n\n// Depth First Search Exploration Algorithm to test connectedness of the Graph (see Graph Algorithms/DFS/exploration), without the tracer & logger commands\nfunction DFSExplore(graph, source) {\n  const stack = [[source, null]];\n  const visited = {};\n  let node;\n  let prev;\n  let i;\n  let temp;\n\n  while (stack.length > 0) {\n    temp = stack.pop();\n    node = temp[0];\n    prev = temp[1];\n\n    if (!visited[node]) {\n      visited[node] = true;\n\n      for (i = 0; i < graph.length; i++) {\n        if (graph[node][i]) {\n          stack.push([i, node]);\n        }\n      }\n    }\n  }\n\n  return visited;\n}\n\nfunction findBridges(graph) {\n  let tempGraph;\n  const bridges = [];\n  let visited;\n\n  for (let i = 0; i < graph.length; i++) {\n    for (let j = 0; j < graph.length; j++) {\n      if (graph[i][j]) { // check if an edge exists\n        // visualize {\n        logger.println(`Deleting edge ${i}->${j} and calling DFSExplore ()`);\n        tracer.visit(j, i);\n        Tracer.delay();\n        tracer.leave(j, i);\n        Tracer.delay();\n        // }\n\n        tempGraph = JSON.parse(JSON.stringify(graph));\n        tempGraph[i][j] = 0;\n        tempGraph[j][i] = 0;\n        visited = DFSExplore(tempGraph, 0);\n\n        if (Object.keys(visited).length === graph.length) {\n          // logger {\n          logger.println('Graph is CONNECTED. Edge is NOT a bridge');\n          // }\n        } else {\n          // logger {\n          logger.println('Graph is DISCONNECTED. Edge IS a bridge');\n          // }\n          bridges.push([i, j]);\n        }\n      }\n    }\n  }\n\n  return bridges;\n}\n\nconst bridges = findBridges(G);\n\n// logger {\nlogger.println('The bridges are: ');\nfor (const i in bridges) {\n  logger.println(`${bridges[i][0]} to ${bridges[i][1]}`);\n}\nlogger.println('NOTE: A bridge is both ways, i.e., from A to B and from B to A, because this is an Undirected Graph');\n// }\n",
  "category": "other",
  "patterns": [
    "custom_data",
    "has_logging"
  ]
}