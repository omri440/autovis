{
  "name": "Cellular Automata",
  "path": "Simple Recursive/Cellular Automata/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array2DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst gridSize = 10;\nconst generations = 4;\nconst fillChance = 0.55;\n\nconst G = [];\nconst nextG = [];\nfor (let i = 0; i < gridSize; i++) {\n  G[i] = [];\n  nextG[i] = [];\n  for (let j = 0; j < gridSize; j++) {\n    if (Math.random() < fillChance || i === 0 || j === 0 || i === gridSize - 1 || j === gridSize - 1) {\n      G[i][j] = '#';\n    } else {\n      G[i][j] = '.';\n    }\n    nextG[i][j] = '#';\n  }\n}\n\n// define tracer variables {\nconst tracer = new Array2DTracer();\nLayout.setRoot(new VerticalLayout([tracer]));\ntracer.set(G);\nTracer.delay();\n// }\n\n// visualize {\nfor (let gi = 0; gi < G.length; gi++) {\n  for (let gj = 0; gj < G[gi].length; gj++) {\n    if (G[gi][gj] === '#') {\n      tracer.patch(gi, gj, G[gi][gj]);\n    }\n  }\n}\n// }\n\nfunction CellularAutomata(fillShape, emptyShape) {\n  const nextGrid = [];\n\n  for (let i = 0; i < G.length; i++) {\n    nextGrid[i] = [];\n    for (let j = 0; j < G[i].length; j++) {\n      let adjCount = 0;\n      let twoAwayCount = 0;\n      // look at the states of the neighboring cells\n      for (let x = -2; x <= 2; x++) {\n        for (let y = -2; y <= 2; y++) {\n          if ((i + x >= 0 && i + x < G.length) && (j + y >= 0 && j + y < G[i].length)) {\n            if (!(x !== 0 && y !== 0) && G[i + x][j + y] === emptyShape) {\n              if (x === -2 || x === 2 || y === -2 || y === 2) {\n                twoAwayCount++;\n              } else {\n                adjCount++;\n              }\n            }\n          }\n        }\n      }\n      // change the current cell's state according to these rules\n      if ((adjCount >= 5)) {\n        nextGrid[i][j] = fillShape;\n      } else if (adjCount <= 1) {\n        if (twoAwayCount < 3) {\n          nextGrid[i][j] = fillShape;\n        } else {\n          nextGrid[i][j] = emptyShape;\n        }\n      } else {\n        nextGrid[i][j] = emptyShape;\n      }\n    }\n  }\n\n  for (let i = 0; i < nextGrid.length; i++) {\n    for (let j = 0; j < nextGrid[i].length; j++) {\n      // visualize {\n      tracer.depatch(i, j, G[i][j]);\n      tracer.select(i, j);\n      Tracer.delay();\n      // }\n      G[i][j] = nextGrid[i][j];\n      // visualize {\n      if (G[i][j] === fillShape) {\n        tracer.patch(i, j, G[i][j]);\n      } else {\n        tracer.patch(i, j, G[i][j]);\n        tracer.depatch(i, j, G[i][j]);\n        tracer.deselect(i, j);\n      }\n      // }\n    }\n  }\n}\n\nfor (let iter = 0; iter < generations; iter++) {\n  CellularAutomata('#', '.');\n}\n",
  "category": "other",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "custom_data",
    "uses_2d_array"
  ]
}