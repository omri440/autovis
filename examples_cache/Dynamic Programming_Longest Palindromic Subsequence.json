{
  "name": "Longest Palindromic Subsequence",
  "path": "Dynamic Programming/Longest Palindromic Subsequence/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst seq = 'BBABCBCAB';\nlet N;\nN = seq.length;\n\nconst L = new Array(N);\n\nlet i;\nlet j;\nfor (i = 0; i < N; i++) {\n  L[i] = new Array(N);\n}\nfor (i = 0; i < N; i++) {\n  L[i][i] = 1;\n}\n\n// define tracer variables {\nconst tracer = new Array1DTracer('Input Text');\nconst matrix = new Array2DTracer('Matrix');\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, matrix, logger]));\ntracer.set(seq);\nmatrix.set(L);\nTracer.delay();\n// }\n\nfunction max(a, b) {\n  if (a > b) {\n    return a;\n  }\n  return b;\n}\n\n// logger {\nlogger.println('LPS for any string with length = 1 is 1');\n// }\nfor (i = 2; i <= N; i++) {\n  // logger {\n  logger.println('--------------------------------------------------');\n  logger.println(`Considering a sub-string of length ${i}`);\n  logger.println('--------------------------------------------------');\n  // }\n  for (j = 0; j < N - i + 1; j++) {\n    const k = j + i - 1;\n    // visualize {\n    tracer.select(j);\n    Tracer.delay();\n    tracer.patch(k);\n    Tracer.delay();\n    // }\n\n    // logger {\n    logger.println(`Comparing ${seq[j]} and ${seq[k]}`);\n    // }\n\n    if (seq[j] === seq[k] && i === 2) {\n      // logger {\n      logger.println(`They are equal and size of the string in the interval${j} to ${k} is 2, so the Longest Palindromic Subsequence in the Given range is 2`);\n      // }\n\n      // visualize {\n      matrix.patch(j, k);\n      Tracer.delay();\n      // }\n\n      L[j][k] = 2;\n      // visualize {\n      matrix.set(L);\n\n      matrix.depatch(j, k);\n      Tracer.delay();\n      // }\n    } else if (seq[j] === seq[k]) {\n      // logger {\n      logger.println(`They are equal, so the Longest Palindromic Subsequence in the Given range is 2 + the Longest Increasing Subsequence between the indices ${j + 1} to ${k - 1}`);\n      // }\n\n      // visualize {\n      matrix.patch(j, k);\n      Tracer.delay();\n      matrix.select(j + 1, k - 1);\n      Tracer.delay();\n      // }\n\n      L[j][k] = L[j + 1][k - 1] + 2;\n      // visualize {\n      matrix.set(L);\n\n      matrix.depatch(j, k);\n      Tracer.delay();\n      matrix.deselect(j + 1, k - 1);\n      Tracer.delay();\n      // }\n    } else {\n      // logger {\n      logger.println(`They are NOT equal, so the Longest Palindromic Subsequence in the Given range is the maximum Longest Increasing Subsequence between the indices ${j + 1} to ${k} and ${j} to ${k - 1}`);\n      // }\n      // visualize {\n      matrix.patch(j, k);\n      Tracer.delay();\n      matrix.select(j + 1, k);\n      Tracer.delay();\n      matrix.select(j, k - 1);\n      Tracer.delay();\n      // }\n\n      L[j][k] = max(L[j + 1][k], L[j][k - 1]);\n      // visualize {\n      matrix.set(L);\n\n      matrix.depatch(j, k);\n      Tracer.delay();\n      matrix.deselect(j + 1, k);\n      Tracer.delay();\n      matrix.deselect(j, k - 1);\n      Tracer.delay();\n      // }\n    }\n    // logger {\n    logger.println('--------------------------------------------------');\n    // }\n    // visualize {\n    tracer.deselect(j);\n    Tracer.delay();\n    tracer.depatch(k);\n    Tracer.delay();\n    // }\n  }\n}\n// logger {\nlogger.println(`Longest Increasing Subsequence of the given string = L[0][${N - 1}]=${L[0][N - 1]}`);\n// }\n",
  "category": "dynamic_programming",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "has_logging",
    "uses_2d_array"
  ]
}