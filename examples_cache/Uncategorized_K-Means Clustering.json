{
  "name": "K-Means Clustering",
  "path": "Uncategorized/K-Means Clustering/code.js",
  "code": "// import visualization libraries {\nconst {\n  Array2DTracer,\n  Layout,\n  LogTracer,\n  Tracer,\n  VerticalLayout,\n  ScatterTracer,\n  Randomize,\n} = require('algorithm-visualizer')\n// }\n\n// define helper functions {\nconst shuffle = a => {\n  const array = a.slice(0)\n  const copy = []\n  let n = array.length\n\n  while (n) {\n    let i = Math.floor(Math.random() * n--)\n    copy.push(array.splice(i, 1)[0])\n  }\n\n  return copy\n}\n\nconst sum = (x, y) => x + y\nconst chooseRandomCenters = (data, k) => shuffle(data).slice(0, k)\nconst pointify = ([x, y]) => `(${x}, ${y})`\nconst arrayify = a => a.map(pointify)\nconst stringify = a => arrayify(a).join(', ')\nconst distance = ([x1, y1], [x2, y2]) => sum(Math.pow(x1 - x2, 2),\n    Math.pow(y1 - y2, 2))\nconst col = (a, i) => a.map(p => p[i])\nconst mean = a => a.reduce(sum, 0) / a.length\nconst centerOfCluster = cluster => [\n  mean(col(cluster, 0)),\n  mean(col(cluster, 1)),\n]\nconst reCalculateCenters = clusters => clusters.map(centerOfCluster)\nconst areCentersEqual = (c1, c2) => !!c1 && !!c2 && !(c1 < c2 || c2 < c1)\n\nfunction cluster(data, centers) {\n  const clusters = centers.map(() => [])\n\n  for (let i = 0; i < data.length; i++) {\n    const point = data[i]\n    let minDistance = Infinity\n    let minDistanceIndex = -1\n\n    for (let j = 0; j < centers.length; j++) {\n      const d = distance(point, centers[j])\n\n      if (d < minDistance) {\n        minDistance = d\n        minDistanceIndex = j\n      }\n    }\n\n    if (!clusters[minDistanceIndex] instanceof Array) {\n      clusters[minDistanceIndex] = []\n    }\n\n    clusters[minDistanceIndex].push(point)\n  }\n\n  return clusters\n}\n\n// }\n\n// define tracer variables {\nconst array2dTracer = new Array2DTracer('Grid')\nconst logTracer = new LogTracer('Console')\nconst scatterTracer = new ScatterTracer('Scatter')\n// }\n\n// define input variables\nconst unClusteredData = Randomize.Array2D(\n    { N: Randomize.Integer({ min: 10, max: 25 }) })\nconst k = Randomize.Integer(\n    { min: 2, max: Math.floor(unClusteredData.length / 5) })\n\nconst recenterAndCluster = (originalClusters) => {\n  const centers = reCalculateCenters(originalClusters)\n  const clusters = cluster(unClusteredData, centers)\n  return { centers, clusters }\n}\n\nconst improve = (loops, clusters, centers) => {\n  const allowImprove = () => loops < 1000\n\n  if (!allowImprove()) {\n    return { clusters, centers }\n  }\n\n  loops++\n\n  const ret = recenterAndCluster(clusters)\n\n  // trace {\n  array2dTracer.set(clusters.map(c => c.map(pointify)))\n  scatterTracer.set([unClusteredData, ...ret.clusters, ret.centers])\n\n  logTracer.println('')\n  logTracer.println(`Iteration #${loops} Result: `)\n  logTracer.println(`\\tClusters:`)\n  logTracer.println(\n      `\\t\\t${ret.clusters.map(c => stringify(c)).join(`\\n\\t\\t`)}`)\n  logTracer.println(`\\tCenters:`)\n  logTracer.println(`\\t\\t${stringify(ret.centers)}`)\n  logTracer.println('')\n\n  Tracer.delay()\n  // }\n\n  if (!allowImprove() || areCentersEqual(centers, ret.centers)) {\n    return ret\n  }\n\n  return improve(loops, ret.clusters, ret.centers)\n}\n\n(function main() {\n  // visualize {\n  Layout.setRoot(new VerticalLayout([scatterTracer, array2dTracer, logTracer]))\n\n  logTracer.println(`Un-clustered data = ${stringify(unClusteredData)}`)\n  array2dTracer.set([unClusteredData.map(pointify)])\n  scatterTracer.set([unClusteredData])\n\n  Tracer.delay()\n  // }\n\n  // Start with random centers\n  const centers = chooseRandomCenters(unClusteredData, k)\n\n  // trace {\n  logTracer.println(\n      `Initial random selected centers = ${stringify(centers)}`)\n  scatterTracer.set([unClusteredData, ...[[], []], centers])\n\n  Tracer.delay()\n  // }\n\n  // Cluster to the random centers\n  const clusters = cluster(unClusteredData, centers)\n\n  // trace {\n  logTracer.println(\n      `Initial clusters = \\n\\t${clusters.map(stringify).join('\\n\\t')}`)\n  array2dTracer.set(clusters.map(c => c.map(pointify)))\n  scatterTracer.set([unClusteredData, ...clusters, centers])\n\n  Tracer.delay()\n  // }\n\n  // start iterations here\n  const ret = improve(0, clusters, centers)\n\n  // trace {\n  Tracer.delay()\n\n  logTracer.println(\n      `Final clustered data = \\n\\t${ret.clusters.map(stringify)\n          .join('\\n\\t')}`)\n  logTracer.println(`Best centers = ${stringify(ret.centers)}`)\n  array2dTracer.set(ret.clusters.map(c => c.map(pointify)))\n  scatterTracer.set([unClusteredData, ...ret.clusters, ret.centers])\n  Tracer.delay()\n  // }\n})()\n",
  "category": "other",
  "patterns": [
    "uses_randomize",
    "uses_2d_array"
  ]
}