{
  "name": "Dijkstra's Shortest Path",
  "path": "Greedy/Dijkstra's Shortest Path/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst G = Randomize.Graph({ N: 5, ratio: 1, directed: false, weighted: true });\nconst MAX_VALUE = Infinity;\nconst S = []; // S[end] returns the distance from start node to end node\nfor (let i = 0; i < G.length; i++) S[i] = MAX_VALUE;\n\n// define tracer variables {\nconst tracer = new GraphTracer().directed(false).weighted();\nconst tracerS = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, tracerS, logger]));\ntracer.log(logger);\ntracer.set(G);\ntracerS.set(S);\nTracer.delay();\n// }\n\nfunction Dijkstra(start, end) {\n  let minIndex;\n  let minDistance;\n  const D = []; // D[i] indicates whether the i-th node is discovered or not\n  for (let i = 0; i < G.length; i++) D.push(false);\n  S[start] = 0; // Starting node is at distance 0 from itself\n  // visualize {\n  tracerS.patch(start, S[start]);\n  Tracer.delay();\n  tracerS.depatch(start);\n  tracerS.select(start);\n  // }\n  let k = G.length;\n  while (k--) {\n    // Finding a node with the shortest distance from S[minIndex]\n    minDistance = MAX_VALUE;\n    for (let i = 0; i < G.length; i++) {\n      if (S[i] < minDistance && !D[i]) {\n        minDistance = S[i];\n        minIndex = i;\n      }\n    }\n    if (minDistance === MAX_VALUE) break; // If there is no edge from current node, jump out of loop\n    D[minIndex] = true;\n    // visualize {\n    tracerS.select(minIndex);\n    tracer.visit(minIndex);\n    Tracer.delay();\n    // }\n    // For every unvisited neighbour of current node, we check\n    // whether the path to it is shorter if going over the current node\n    for (let i = 0; i < G.length; i++) {\n      if (G[minIndex][i] && S[i] > S[minIndex] + G[minIndex][i]) {\n        S[i] = S[minIndex] + G[minIndex][i];\n        // visualize {\n        tracerS.patch(i, S[i]);\n        tracer.visit(i, minIndex, S[i]);\n        Tracer.delay();\n        tracerS.depatch(i);\n        tracer.leave(i, minIndex);\n        Tracer.delay();\n        // }\n      }\n    }\n    // visualize {\n    tracer.leave(minIndex);\n    Tracer.delay();\n    // }\n  }\n  // logger {\n  if (S[end] === MAX_VALUE) {\n    logger.println(`there is no path from ${start} to ${end}`);\n  } else {\n    logger.println(`the shortest path from ${start} to ${end} is ${S[end]}`);\n  }\n  // }\n}\n\nconst s = Randomize.Integer({ min: 0, max: G.length - 1 }); // s = start node\nlet e; // e = end node\ndo {\n  e = Randomize.Integer({ min: 0, max: G.length - 1 });\n} while (s === e);\n// logger {\nlogger.println(`finding the shortest path from ${s} to ${e}`);\nTracer.delay();\n// }\nDijkstra(s, e);\n",
  "category": "greedy",
  "patterns": [
    "patch_depatch",
    "uses_randomize",
    "has_logging"
  ]
}