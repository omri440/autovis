{
  "name": "Shortest Unsorted Continuous Subarray",
  "path": "Uncategorized/Shortest Unsorted Continuous Subarray/code.js",
  "code": "// import visualization libraries {\n  const { Tracer, LogTracer, Array1DTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n  // }\n  \n  // define tracer variables {\n  const tracer = new Array1DTracer('Sequence');\n  const D = [2, 6, 4, 8, 10, 9, 15];\n  tracer.set(D);\n  const logger = new LogTracer();\n  Layout.setRoot(new VerticalLayout([tracer, logger]));\n  Tracer.delay();\n  // }\n  \n  function findUnsortedSubarray(nums) {\n      let min = Number.MAX_VALUE;\n      let max = Number.MIN_VALUE;\n      let flag = false;\n      // visualize {\n      let minIndex = -1;\n      let maxIndex = -1;\n      // }\n  \n      for (let i = 1; i < nums.length; i++) {\n          // visualize {\n          tracer.deselect(i - 2, i - 1);\n          tracer.select(i - 1, i);\n          Tracer.delay();\n          // }\n          \n          if (nums[i] < nums[i - 1]) {\n              flag = true;\n          }\n          if (flag) {\n              min = Math.min(min, nums[i]);\n              // visualize {\n              if (min === nums[i]) {\n                  tracer.depatch(minIndex);\n                  minIndex = i;\n                  tracer.patch(i);\n              }\n              Tracer.delay();\n              // }\n          }\n      }\n      \n      // visualize {\n      tracer.depatch(minIndex);\n      tracer.deselect(nums.length - 2);\n      tracer.deselect(nums.length - 1);\n      // }\n  \n      // logger {\n      logger.println(`min = ${min}`);\n      Tracer.delay();\n      // }\n  \n      flag = false;\n      for (let i = nums.length - 2; i >= 0; i--) {\n          // visualize {\n          tracer.deselect(i + 1, i + 2);\n          tracer.select(i, i + 1);\n          Tracer.delay();\n          // }\n  \n          if (nums[i] > nums[i + 1]) {\n              flag = true;\n          }\n          if (flag) {\n              max = Math.max(max, nums[i]);\n              // visualize {\n              if (max === nums[i]) {\n                  tracer.depatch(maxIndex);\n                  maxIndex = i;\n                  tracer.patch(i);\n              }\n              Tracer.delay();\n              // }\n          }\n      }\n      \n      // visualize {\n      tracer.depatch(maxIndex);\n      tracer.deselect(0);\n      tracer.deselect(1);\n      Tracer.delay();\n      // }\n  \n      // logger {\n      logger.println(`max = ${max}`);\n      // }\n  \n      let l;\n      let r;\n      for (l = 0; l < nums.length; l++) {\n          // visualize {\n          tracer.deselect(l - 1);\n          tracer.select(l);\n          Tracer.delay();\n          // }\n          \n          if (min < nums[l]) {\n              // visualize {\n              tracer.patch(l);\n              Tracer.delay();\n              // }\n              break;\n          }\n      }\n      \n      for (r = nums.length - 1; r >= 0; r--) {\n          // visualize {\n          tracer.deselect(r + 1);\n          tracer.select(r);\n          Tracer.delay();\n          // }\n          \n          if (max > nums[r]) {\n              // visualize {\n              tracer.patch(r);\n              Tracer.delay();\n              // }\n              break;\n          }\n      }\n      \n      // visualize {\n      tracer.depatch(l);\n      tracer.depatch(r);\n      tracer.select(l, r);\n      Tracer.delay();\n      // }\n      \n      const result = r - l < 0\n          ? 0\n          : r - l + 1;\n          \n      // logger {\n      logger.println(`result = ${result}`);\n      Tracer.delay();\n      // }\n  \n      return result;\n  }\n  findUnsortedSubarray(D);",
  "category": "sorting",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "custom_data",
    "has_logging"
  ]
}