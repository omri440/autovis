{
  "name": "Levenshtein's Edit Distance",
  "path": "Dynamic Programming/Levenshtein's Edit Distance/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst str1 = 'stack';\nconst str2 = 'racket';\nconst table = new Array(str1.length + 1);\n\nfor (let i = 0; i < str1.length + 1; i++) {\n  table[i] = new Array(str2.length + 1).fill(-1);\n  table[i][0] = i;\n}\nfor (let i = 1; i < str2.length + 1; i++) {\n  table[0][i] = i;\n}\n\n// define tracer variables {\nconst tracer = new Array2DTracer('Distance Table');\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.set(table);\nTracer.delay();\n// }\n\n// logger {\nlogger.println('Initialized DP Table');\nlogger.println(`Y-Axis (Top to Bottom): ${str1}`);\nlogger.println(`X-Axis (Left to Right): ${str2}`);\n// }\n\nconst dist = (function editDistance(str1, str2, table) {\n  // display grid with words\n  // logger {\n  logger.println(`*** ${str2.split('').join(' ')}`);\n  table.forEach((item, index) => {\n    const character = (index === 0) ? '*' : str1[index - 1];\n    logger.println(`${character}\\t${item}`);\n  });\n  // }\n\n  // begin ED execution\n  for (let i = 1; i < str1.length + 1; i++) {\n    for (let j = 1; j < str2.length + 1; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        // visualize {\n        tracer.select(i - 1, j - 1);\n        Tracer.delay();\n        // }\n        table[i][j] = table[i - 1][j - 1];\n        // visualize {\n        tracer.patch(i, j, table[i][j]);\n        Tracer.delay();\n        tracer.depatch(i, j);\n        tracer.deselect(i - 1, j - 1);\n        // }\n      } else {\n        // visualize {\n        tracer.select(i - 1, j);\n        tracer.select(i, j - 1);\n        tracer.select(i - 1, j - 1);\n        Tracer.delay();\n        // }\n        table[i][j] = Math.min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1]) + 1;\n        // visualize {\n        tracer.patch(i, j, table[i][j]);\n        Tracer.delay();\n        tracer.depatch(i, j);\n        tracer.deselect(i - 1, j);\n        tracer.deselect(i, j - 1);\n        tracer.deselect(i - 1, j - 1);\n        // }\n      }\n    }\n  }\n\n  // visualize {\n  tracer.select(str1.length, str2.length);\n  // }\n  return table[str1.length][str2.length];\n}(str1, str2, table));\n\n// logger {\nlogger.println(`Minimum Edit Distance: ${dist}`);\n// }\n",
  "category": "dynamic_programming",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "has_logging",
    "uses_2d_array"
  ]
}