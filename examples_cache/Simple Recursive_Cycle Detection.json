{
  "name": "Cycle Detection",
  "path": "Simple Recursive/Cycle Detection/code.js",
  "code": "// import visualization libraries {\nconst { Array2DTracer, Layout, LogTracer, GraphTracer, Tracer, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n\n// define tracer variables {\nfunction ListNode(val) {\n    this.val = val\n    this.next = null\n}\n\nconst node0 = new ListNode(0)\nconst node1 = new ListNode(1)\nconst node2 = new ListNode(2)\nconst node3 = new ListNode(3)\nconst node4 = new ListNode(4)\nconst node5 = new ListNode(5)\nconst node6 = new ListNode(6)\n\nconst list = node0\nlist.next = node1\nlist.next.next = node2\nlist.next.next.next = node3\nlist.next.next.next.next = node4\nlist.next.next.next.next.next = node5\nlist.next.next.next.next.next.next = node6\nlist.next.next.next.next.next.next.next = node2\n\nconst graphTracer = new GraphTracer(\"Linked List\").directed()\nconst logTracer = new LogTracer(\"Console\")\nLayout.setRoot(new VerticalLayout([graphTracer, logTracer]))\n\ngraphTracer.addNode(node0.val)\ngraphTracer.addNode(node1.val)\ngraphTracer.addNode(node2.val)\ngraphTracer.addNode(node3.val)\ngraphTracer.addNode(node4.val)\ngraphTracer.addNode(node5.val)\ngraphTracer.addNode(node6.val)\ngraphTracer.addEdge(node0.val, node1.val)\ngraphTracer.addEdge(node1.val, node2.val)\ngraphTracer.addEdge(node2.val, node3.val)\ngraphTracer.addEdge(node3.val, node4.val)\ngraphTracer.addEdge(node4.val, node5.val)\ngraphTracer.addEdge(node5.val, node6.val)\ngraphTracer.addEdge(node6.val, node2.val)\nTracer.delay()\n// }\n\nvar listHasCycle = function(head) {\n    // visualize {\n    graphTracer.select(head.val)\n    graphTracer.visit(head.val)\n    Tracer.delay()\n    graphTracer.deselect(head.val)\n    graphTracer.leave(head.val)\n    // }\n    \n    // 1. is there a cycle?\n    let slow = head.next\n    let fast = head.next.next\n    // visualize {\n    graphTracer.select(slow.val)\n    graphTracer.visit(fast.val)\n    Tracer.delay()\n    graphTracer.deselect(slow.val)\n    graphTracer.leave(fast.val)\n    // }\n    while (slow !== fast) {\n        slow = slow.next\n        fast = fast.next.next\n        // visualize {\n        graphTracer.select(slow.val)\n        graphTracer.visit(fast.val)\n        Tracer.delay()\n        graphTracer.deselect(slow.val)\n        graphTracer.leave(fast.val)\n        // }\n    }\n\n    // 2. where does the cycle start?\n    let cycleStartPosition = 0\n    slow = head\n    // visualize {\n    graphTracer.select(slow.val)\n    graphTracer.visit(fast.val)\n    Tracer.delay()\n    graphTracer.deselect(slow.val)\n    graphTracer.leave(fast.val)\n    // }\n    while (slow !== fast) {\n        slow = slow.next\n        fast = fast.next\n        cycleStartPosition += 1\n        // visualize {\n        graphTracer.select(slow.val)\n        graphTracer.visit(fast.val)\n        Tracer.delay()\n        graphTracer.deselect(slow.val)\n        graphTracer.leave(fast.val)\n        // }\n    }\n\n    // 3. what is the length of the cycle?\n    let cycleLength = 1\n    fast = slow.next\n    // visualize {\n    graphTracer.select(slow.val)\n    graphTracer.visit(fast.val)\n    Tracer.delay()\n    graphTracer.deselect(slow.val)\n    graphTracer.leave(fast.val)\n    // }\n    while (slow !== fast) {\n        fast = fast.next\n        cycleLength += 1\n        // visualize {\n        graphTracer.select(slow.val)\n        graphTracer.visit(fast.val)\n        Tracer.delay()\n        graphTracer.deselect(slow.val)\n        graphTracer.leave(fast.val)\n        // }\n    }\n\n    return {\n      cycleLength,\n      cycleStartPosition,\n    }\n}\n// log {\nconst res = listHasCycle(list)\nlogTracer.print(`cycle start position: ${res.cycleStartPosition}`)\nlogTracer.print(\"\\n\")\nlogTracer.print(`cycle length: ${res.cycleLength}`)\n// }",
  "category": "other",
  "patterns": [
    "select_deselect",
    "uses_2d_array"
  ]
}