{
  "name": "Tarjan's Strongly Connected Components",
  "path": "Brute Force/Tarjan's Strongly Connected Components/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst G = [\n  [0, 0, 1, 1, 0, 0],\n  [1, 0, 0, 0, 0, 0],\n  [0, 1, 0, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0],\n  [0, 0, 0, 0, 0, 1],\n  [0, 0, 0, 0, 1, 0],\n];\n\nconst disc = new Array(G.length);\nconst low = new Array(G.length);\nconst stackMember = new Array(G.length);\nconst st = [];\nconst carry = { time: 0 };\n\nfor (let i = 0; i < G.length; i++) {\n  disc[i] = -1;\n  low[i] = -1;\n  stackMember[i] = false;\n}\n\n// define tracer variables {\nconst graphTracer = new GraphTracer();\ngraphTracer.set(G);\nconst discTracer = new Array1DTracer('Disc');\nconst lowTracer = new Array1DTracer('Low');\nconst stackMemberTracer = new Array1DTracer('stackMember');\nconst stTracer = new Array1DTracer('st');\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([graphTracer, discTracer, lowTracer, stackMemberTracer, stTracer, logger]));\ndiscTracer.set(disc);\nlowTracer.set(low);\nstackMemberTracer.set(stackMember);\nstTracer.set(st);\nTracer.delay();\n// }\n\nfunction SCCVertex(u, disc, low, st, stackMember, carry) {\n  // visualize {\n  graphTracer.visit(u);\n  Tracer.delay();\n  // }\n\n  disc[u] = ++carry.time;\n  // visualize {\n  discTracer.patch(u, carry.time);\n  Tracer.delay();\n  // }\n\n  low[u] = carry.time;\n  // visualize {\n  lowTracer.patch(u, carry.time);\n  Tracer.delay();\n  // }\n\n  st.push(u);\n  // visualize {\n  stTracer.set(st);\n  Tracer.delay();\n  // }\n\n  stackMember[u] = true;\n  // visualize {\n  stackMemberTracer.patch(u, true);\n  Tracer.delay();\n  // }\n\n  // Go through all vertices adjacent to this\n  for (let v = 0; v < G[u].length; v++) {\n    if (G[u][v]) {\n      // If v is not visited yet, then recur for it\n      if (disc[v] === -1) {\n        SCCVertex(v, disc, low, st, stackMember, carry);\n\n        // Check if the subtree rooted with 'v' has a\n        // connection to one of the ancestors of 'u'\n        low[u] = Math.min(low[u], low[v]);\n        // visualize {\n        lowTracer.patch(u, low[u]);\n        Tracer.delay();\n        // }\n      }\n\n      // Update low value of 'u' only of 'v' is still in stack\n      // (i.e. it's a back edge, not cross edge).\n      else if (stackMember[v] === true) {\n        low[u] = Math.min(low[u], disc[v]);\n        // visualize {\n        lowTracer.patch(u, low[u]);\n        Tracer.delay();\n        // }\n      }\n    }\n  }\n\n  // head node found, pop the stack and print an SCC\n  let w = 0; // To store stack extracted vertices\n  if (low[u] === disc[u]) {\n    while (st[st.length - 1] !== u) {\n      w = st.pop();\n      // visualize {\n      stTracer.set(st);\n      Tracer.delay();\n\n      logger.println(w);\n      Tracer.delay();\n      // }\n\n      stackMember[w] = false;\n      // visualize {\n      stackMemberTracer.patch(w, false);\n      Tracer.delay();\n      // }\n    }\n\n    w = st.pop();\n    // visualize {\n    stTracer.set(st);\n    Tracer.delay();\n\n    logger.println(w);\n    Tracer.delay();\n    logger.println('------');\n    // }\n\n    stackMember[w] = false;\n    // visualize {\n    stackMemberTracer.patch(w, false);\n    Tracer.delay();\n    // }\n  }\n}\n\nfor (let i = 0; i < G.length; i++) {\n  if (disc[i] === -1) {\n    SCCVertex(i, disc, low, st, stackMember, carry);\n  }\n}\n",
  "category": "other",
  "patterns": [
    "custom_data",
    "has_logging"
  ]
}