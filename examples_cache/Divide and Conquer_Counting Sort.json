{
  "name": "Counting Sort",
  "path": "Divide and Conquer/Counting Sort/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst arrayTracer = new Array1DTracer('Array');\nconst countsTracer = new Array1DTracer('Counts');\nconst sortedArrayTracer = new Array1DTracer('Sorted Array');\nLayout.setRoot(new VerticalLayout([arrayTracer, countsTracer, sortedArrayTracer]));\n// }\n\n// define input variables\nconst N = 20; // the size of an array\nconst array = Randomize.Array1D({ N, value: () => Randomize.Integer({ min: 0, max: 9 }) });\n\n(function main() {\n  // find the maximum value that will decide the size of counts array\n  const max = Math.max(...array);\n  const counts = new Array(max + 1).fill(0);\n  // visualize {\n  arrayTracer.set(array);\n  countsTracer.set(counts);\n  Tracer.delay();\n  // }\n\n  // store counts of each number\n  for (let i = 0; i < N; i++) {\n    const number = array[i];\n    counts[number]++;\n    // visualize {\n    arrayTracer.select(i);\n    countsTracer.patch(number, counts[number]);\n    Tracer.delay();\n    countsTracer.depatch(number);\n    arrayTracer.deselect(i);\n    // }\n  }\n\n  // calculate the prefix sums\n  for (let i = 1; i <= max; i++) {\n    counts[i] += counts[i - 1];\n    // visualize {\n    countsTracer;\n    countsTracer.select(i - 1);\n    countsTracer.patch(i, counts[i]);\n    Tracer.delay();\n    countsTracer.depatch(i);\n    countsTracer.deselect(i - 1);\n    // }\n  }\n\n  // create a sorted array based on the prefix sums\n  const sortedArray = new Array(N);\n  // visualize {\n  sortedArrayTracer.set(sortedArray);\n  // }\n  for (let i = N - 1; i >= 0; i--) {\n    const number = array[i];\n    const count = counts[number];\n    sortedArray[count - 1] = number;\n    counts[number]--;\n    // visualize {\n    arrayTracer.select(i);\n    countsTracer.select(number);\n    sortedArrayTracer.patch(count - 1, sortedArray[count - 1]);\n    countsTracer.patch(number, counts[number]);\n    Tracer.delay();\n    sortedArrayTracer.depatch(count - 1);\n    countsTracer.depatch(number);\n    countsTracer.deselect(number);\n    arrayTracer.deselect(i);\n    // }\n  }\n})();\n",
  "category": "sorting",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "uses_randomize"
  ]
}