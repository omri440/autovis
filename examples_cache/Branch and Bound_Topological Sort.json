{
  "name": "Topological Sort",
  "path": "Branch and Bound/Topological Sort/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// G[i][j] indicates whether the path from the i-th node to the j-th node exists or not. NOTE: The graph must be Directed-Acyclic\nconst G = [\n  [0, 0, 0, 0, 0, 0],\n  [0, 0, 1, 0, 0, 0],\n  [0, 0, 0, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0],\n  [1, 0, 0, 1, 0, 0],\n  [1, 1, 0, 0, 0, 0],\n];\n\n// define tracer variables {\nconst tracer = new GraphTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.log(logger);\ntracer.set(G);\nTracer.delay();\n// }\n\nconst inDegrees = Array(...Array(G.length)).map(Number.prototype.valueOf, 0); // create an Array of G.length number of 0s\nconst Q = [];\nlet iter = 0;\nlet i;\n\n// logger {\nlogger.println('Calculating in-degrees for each Node...');\n// }\n\nfor (let currNode = 0; currNode < G.length; currNode++) {\n  for (let currNodeNeighbor = 0; currNodeNeighbor < G.length; currNodeNeighbor++) {\n    if (G[currNode][currNodeNeighbor]) {\n      // visualize {\n      logger.println(`${currNodeNeighbor} has an incoming edge from ${currNode}`);\n      tracer.visit(currNodeNeighbor, currNode);\n      Tracer.delay();\n      // }\n      inDegrees[currNodeNeighbor]++;\n      // visualize {\n      tracer.leave(currNodeNeighbor, currNode);\n      Tracer.delay();\n      // }\n    }\n  }\n}\n// logger {\nlogger.println(`Done. In-Degrees are: [ ${String(inDegrees)} ]`);\nlogger.println('');\n\nlogger.println('Initializing queue with all the sources (nodes with no incoming edges)');\n// }\ninDegrees.map((indegrees, node) => {\n  // visualize {\n  tracer.visit(node);\n  Tracer.delay();\n  // }\n  if (!indegrees) {\n    // logger {\n    logger.println(`${node} is a source`);\n    // }\n    Q.push(node);\n  }\n  // visualize {\n  tracer.leave(node);\n  Tracer.delay();\n  // }\n});\n// logger {\nlogger.println(`Done. Initial State of Queue: [ ${String(Q)} ]`);\nlogger.println('');\n// }\n\n// begin topological sort (kahn)\nwhile (Q.length > 0) {\n  // logger {\n  logger.println(`Iteration #${iter}. Queue state: [ ${String(Q)} ]`);\n  // }\n  const currNode = Q.shift();\n  // visualize {\n  tracer.visit(currNode);\n  Tracer.delay();\n  // }\n\n  for (i = 0; i < G.length; i++) {\n    if (G[currNode][i]) {\n      // visualize {\n      logger.println(`${i} has an incoming edge from ${currNode}. Decrementing ${i}'s in-degree by 1.`);\n      tracer.visit(i, currNode);\n      Tracer.delay();\n      // }\n      inDegrees[i]--;\n      // visualize {\n      tracer.leave(i, currNode);\n      Tracer.delay();\n      // }\n\n      if (!inDegrees[i]) {\n        // logger {\n        logger.println(`${i}'s in-degree is now 0. Enqueuing ${i}`);\n        // }\n        Q.push(i);\n      }\n    }\n  }\n  // visualize {\n  tracer.leave(currNode);\n  Tracer.delay();\n  // }\n  // logger {\n  logger.println(`In-degrees are: [${String(inDegrees)} ]`);\n  logger.println('-------------------------------------------------------------------');\n  // }\n  \n  iter++;\n}\n",
  "category": "sorting",
  "patterns": [
    "custom_data",
    "has_logging"
  ]
}