{
  "name": "Merge Sort",
  "path": "Divide and Conquer/Merge Sort/topDown.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, ChartTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst chart = new ChartTracer();\nconst tracer = new Array1DTracer();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([chart, tracer, logger]));\nconst D = Randomize.Array1D({ N: 15 });\ntracer.set(D);\ntracer.chart(chart);\nTracer.delay();\n// }\n\n// logger {\nlogger.println(`original array = [${D.join(', ')}]`);\n// }\n\nfunction mergeSort(start, end) {\n  if (Math.abs(end - start) <= 1) return [];\n  const middle = Math.ceil((start + end) / 2);\n\n  mergeSort(start, middle);\n  mergeSort(middle, end);\n\n  // logger {\n  logger.println(`divide left[${start}, ${middle - 1}], right[${middle}, ${end - 1}]`);\n  // }\n  return mergeSort.merge(start, middle, end);\n}\n\nmergeSort.merge = (start, middle, end) => {\n  const leftSize = middle - start;\n  const rightSize = end - middle;\n  const maxSize = Math.max(leftSize, rightSize);\n  const size = end - start;\n  const left = [];\n  const right = [];\n  let i;\n\n  for (i = 0; i < maxSize; i++) {\n    if (i < leftSize) {\n      left.push(D[start + i]);\n      // visualize {\n      tracer.select(start + i);\n      logger.println(`insert value into left array[${i}] = ${D[start + i]}`);\n      Tracer.delay();\n      // }\n    }\n    if (i < rightSize) {\n      right.push(D[middle + i]);\n      // visualize {\n      tracer.select(middle + i);\n      logger.println(`insert value into right array[${i}] = ${D[middle + i]}`);\n      Tracer.delay();\n      // }\n    }\n  }\n  // logger {\n  logger.println(`left array = [${left.join(', ')}], ` + `right array = [${right.join(', ')}]`);\n  // }\n\n  i = 0;\n  while (i < size) {\n    if (left[0] && right[0]) {\n      if (left[0] > right[0]) {\n        D[start + i] = right.shift();\n        // logger {\n        logger.println(`rewrite from right array[${i}] = ${D[start + i]}`);\n        // }\n      } else {\n        D[start + i] = left.shift();\n        // logger {\n        logger.println(`rewrite from left array[${i}] = ${D[start + i]}`);\n        // }\n      }\n    } else if (left[0]) {\n      D[start + i] = left.shift();\n      // logger {\n      logger.println(`rewrite from left array[${i}] = ${D[start + i]}`);\n      // }\n    } else {\n      D[start + i] = right.shift();\n      // logger {\n      logger.println(`rewrite from right array[${i}] = ${D[start + i]}`);\n      // }\n    }\n\n    // visualize {\n    tracer.deselect(start + i);\n    tracer.patch(start + i, D[start + i]);\n    Tracer.delay();\n    tracer.depatch(start + i);\n    // }\n    i++;\n  }\n\n  const tempArray = [];\n  for (i = start; i < end; i++) tempArray.push(D[i]);\n  // logger {\n  logger.println(`merged array = [${tempArray.join(', ')}]`);\n  // }\n};\n\nmergeSort(0, D.length);\n// logger {\nlogger.println(`sorted array = [${D.join(', ')}]`);\n// }\n",
  "category": "sorting",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "uses_randomize",
    "has_logging",
    "uses_chart"
  ]
}