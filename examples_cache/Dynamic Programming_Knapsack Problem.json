{
  "name": "Knapsack Problem",
  "path": "Dynamic Programming/Knapsack Problem/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, Array1DTracer, Array2DTracer, LogTracer, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\nconst val = [1, 4, 5, 7]; // The value of all available items\nconst wt = [1, 3, 4, 5]; // The weights of available items\nconst W = 7; // The maximum weight we can carry in our collection\nconst N = val.length;\nconst DP = new Array(N + 1);\n\nfor (let i = 0; i < N + 1; i++) {\n  DP[i] = new Array(W + 1);\n  for (let j = 0; j < W + 1; j++) {\n    DP[i][j] = 0;\n  }\n}\n\n// define tracer variables {\nconst tracer = new Array2DTracer('Knapsack Table');\nconst valuesTracer = new Array1DTracer('Values');\nconst weightsTracer = new Array1DTracer('Weights');\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, valuesTracer, weightsTracer, logger]));\ntracer.set(DP);\nvaluesTracer.set(val);\nweightsTracer.set(wt);\nTracer.delay();\n// }\n\nfor (let i = 0; i <= N; i++) {\n  for (let j = 0; j <= W; j++) {\n    if (i === 0 || j === 0) {\n      /*\n      If we have no items or maximum weight we can take in collection is 0\n      then the total weight in our collection is 0\n      */\n      DP[i][0] = 0;\n      // visualize {\n      tracer.patch(i, j, DP[i][j]);\n      Tracer.delay();\n      tracer.depatch(i, j);\n      // }\n    } else if (wt[i - 1] <= j) { // take the current item in our collection\n      // visualize {\n      weightsTracer.select(i - 1);\n      valuesTracer.select(i - 1);\n      Tracer.delay();\n      tracer.select(i - 1, j - wt[i - 1]);\n      tracer.select(i - 1, j);\n      Tracer.delay();\n      // }\n      const A = val[i - 1] + DP[i - 1][j - wt[i - 1]];\n      const B = DP[i - 1][j];\n      /*\n      find the maximum of these two values\n      and take which gives us a greater weight\n       */\n      if (A > B) {\n        DP[i][j] = A;\n        // visualize {\n        tracer.patch(i, j, DP[i][j]);\n        Tracer.delay();\n        // }\n      } else {\n        DP[i][j] = B;\n        // visualize {\n        tracer.patch(i, j, DP[i][j]);\n        Tracer.delay();\n        // }\n      }\n      // visualize {\n      // opt subproblem depatch\n      tracer.depatch(i, j);\n      tracer.deselect(i - 1, j);\n      tracer.deselect(i - 1, j - wt[i - 1]);\n      valuesTracer.deselect(i - 1);\n      weightsTracer.deselect(i - 1);\n      // }\n    } else { // leave the current item from our collection\n      DP[i][j] = DP[i - 1][j];\n      // visualize {\n      tracer.patch(i, j, DP[i][j]);\n      Tracer.delay();\n      tracer.depatch(i, j);\n      // }\n    }\n  }\n}\n\n// logger {\nlogger.println(` Best value we can achieve is ${DP[N][W]}`);\n// }\n",
  "category": "dynamic_programming",
  "patterns": [
    "select_deselect",
    "patch_depatch",
    "custom_data",
    "has_logging",
    "uses_2d_array"
  ]
}