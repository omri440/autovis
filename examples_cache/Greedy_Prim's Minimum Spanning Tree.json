{
  "name": "Prim's Minimum Spanning Tree",
  "path": "Greedy/Prim's Minimum Spanning Tree/code.js",
  "code": "// import visualization libraries {\nconst { Tracer, GraphTracer, LogTracer, Randomize, Layout, VerticalLayout } = require('algorithm-visualizer');\n// }\n\n// define tracer variables {\nconst tracer = new GraphTracer().directed(false).weighted();\nconst logger = new LogTracer();\nLayout.setRoot(new VerticalLayout([tracer, logger]));\ntracer.log(logger);\n/* let G = [ // G[i][j] indicates the weight of the path from the i-th node to the j-th node\n [0, 3, 0, 1, 0],\n [5, 0, 1, 2, 4],\n [1, 0, 0, 2, 0],\n [0, 2, 0, 0, 1],\n [0, 1, 3, 0, 0]\n ]; */\nconst G = Randomize.Graph({ N: 10, ratio: .4, directed: false, weighted: true });\ntracer.set(G);\nTracer.delay();\n// }\n\nfunction prim() {\n  // Finds a tree so that there exists a path between\n  // every two nodes while keeping the cost minimal\n  let minD;\n\n  let minI;\n  let minJ;\n  let sum = 0;\n  const D = [];\n  for (let i = 0; i < G.length; i++) D.push(0);\n  D[0] = 1; // First node is visited\n  for (let k = 0; k < G.length - 1; k++) { // Searching for k edges\n    minD = Infinity;\n    for (let i = 0; i < G.length; i++) {\n      if (D[i]) // First node in an edge must be visited\n      {\n        for (let j = 0; j < G.length; j++) {\n          if (!D[j] && G[i][j]) {\n            // visualize {\n            tracer.visit(i, j);\n            Tracer.delay();\n            // }\n            // Second node must not be visited and must be connected to first node\n            if (G[i][j] < minD) {\n              // Searching for cheapest edge which satisfies requirements\n              minD = G[i][j];\n              minI = i;\n              minJ = j;\n            }\n            // visualize {\n            tracer.leave(i, j);\n            Tracer.delay();\n            // }\n          }\n        }\n      }\n    }\n    // visualize {\n    tracer.visit(minI, minJ);\n    Tracer.delay();\n    // }\n    D[minJ] = 1; // Visit second node and insert it into or tree\n    sum += G[minI][minJ];\n  }\n  // logger {\n  logger.println(`The sum of all edges is: ${sum}`);\n  // }\n}\n\n// logger {\nlogger.println('nodes that belong to minimum spanning tree are: ');\n// }\nprim();\n",
  "category": "graph",
  "patterns": [
    "uses_randomize",
    "has_logging"
  ]
}